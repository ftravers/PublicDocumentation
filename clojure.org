#+OPTIONS: toc:2
* References:
https://cljdoc.org/
https://crossclj.info/

* CIDER REPL

| Keys    | Meaning                          |
|---------+----------------------------------|
| C-c A-j | Start REPL                       |
| C-c A-n | Change Namespace to that of file |
* WebSockets

** Client

In =project.clj= put:

[org.clojure/google-closure-library "0.0-20140226-71326067"]

#+BEGIN_SRC clojurescript
(:require [goog.net.WebSocket :as ws]))
(defn do-websocket []
  (let [url "ws://localhost:8080"
        ws (js/WebSocket. url)]
    (set! (.-onmessage ws) (fn [evt] (js/alert (.-data evt))))
    (set! (.-onclose ws) (fn [evt] (js/alert "closed")))
    (set! (.-onopen ws) (fn [evt] (.send ws "hello")))))
#+END_SRC

** Server

In =project.clj= put:

 [http-kit "2.1.19"]

This comes from the httpkit example server.  This an echo server that
you can also test from a chrome WebSocket tester app.

#+BEGIN_SRC clojure
(ns pcbe.httpkit-server
  (:require
   [org.httpkit.server
    :refer [with-channel on-close websocket? on-receive send! run-server]]))
(defonce server (atom nil))
(defn stop-server []
  (when-not (nil? @server)
    (@server :timeout 100)
    (reset! server nil)))
(defn handler [req]
  (with-channel req channel
    (on-close channel (fn [status]
                        (println "channel closed")))
    (if (websocket? channel)
      (println "WebSocket channel")
      (println "HTTP channel"))
    (on-receive
     channel
     (fn [data]                   
       (send! channel data)))))   
(defn -main [&args]
  (reset! server (run-server handler {:port 8080})))
#+END_SRC
* core.async - pub/sub

The requires:

: (:require-macros [cljs.core.async.macros :refer [go]])
: (:require [cljs.core.async :refer [<! >! chan pub sub]])

Create a channel

: (def input-chan (chan))

Now overlay that channel with a `publication`

: (def our-pub (pub input-chan :msg-type))

Here *:msg-type* is our function that is used to filter messages sent
over the channel.

To use the publish-channel we just write messages to the original
channel: 

: (go (>! input-chan {:msg-type :greeting :text "hello"}))

This doesn't block, because we have overlayed the publication flavor
onto the channel.  Since there are no subscribers as yet, this message
just dissappears into the ether! :)

To receive messages of :msg-type :greeting we need to to subscribe to
our publication with the *sub* function.

: (def output-chan (chan))
: (sub our-pub :greeting output-chan)

sub takes a publication, a topic, and a subscribing channel. The
subscribing channel will receive all values from the publication for
which (= (topic-fn pub-msg) topic):

We can handle the received values like so:

#+BEGIN_SRC clojure
(go-loop []
  (let [{:keys [text]} (<! output-chan)]
    (println text)
    (recur)))
#+END_SRC

We create a new channel.  Then we subscribe, passing our publication
as the first arg, the value to match on, and finally the channel to
put our matches on.

Now when we put a message on the original channel it will be 'caught'
by the subscribed channel

: (go (>! input-chan {:msg-type :greeting :text "Hi there"}))
* fast repl start

You can create a classpath file with

: lein classpath > my.cp

Run java quickly with: drip
https://github.com/ninjudd/drip

drip -cp $(cat my.cp) clojure.main -r


DRIP_INIT_CLASS="pcbe.http-test" drip -cp $(cat my.cp) clojure.main

rlwrap -a,, -pBlue drip -cp clojure.jar clojure.main


I'm not sure if there is way to use drip to speed up the launching and running of tests, but that would be great if there was.
* sayid

ref: http://bpiel.github.io/sayid/

add ~[com.billpiel/sayid "0.0.10"]~ as a PLUGIN dependency to project.cljc

eval the namespace you care about in the REPL

trace the namespace with ~C-c s t p~, eg: ~om.*~

run some code that uses that namespace.

get report with ~C-c s w~

Go to any line and hit ~i~ (inspect).  ~BACKSPACE~ to collapse.

C-c s t D -- Disable all traces
* lein repl

When I start the repl I land in this namespace:

#+BEGIN_SRC clojure
  omn1be.core=> 
#+END_SRC

Here is the src tree:

#+BEGIN_SRC 
% tree src      
src
`-- omn1be
    |-- core.clj
    `-- websocket.clj
#+END_SRC

Now I can load the websocket file with:

#+BEGIN_SRC clojure
  omn1be.core=> (load "websocket")
#+END_SRC

if I was only in the ~omn1be~ namespace then the load command would
look like:

#+BEGIN_SRC clojure
  omn1be=> (load "omn1be/websocket")
#+END_SRC

I can move around to different namespaces with the ~in-ns~ function:

#+BEGIN_SRC clojure
  omn1be=> (in-ns 'omn1be.websocket)
  #namespace[omn1be.websocket]
  omn1be.websocket=>
#+END_SRC
* destructuring
* transducers

Normally, we'd process a sequence like so:

#+BEGIN_SRC clojure
(->> aseq (map inc) (filter even?))
#+END_SRC

Instead we gather up our list processing functions like so:

#+BEGIN_SRC clojure
(def xform (comp (map inc) (filter even?)))
#+END_SRC

Then we can use ~xform~ in a couple of ways:

lazily transform the data (one lazy sequence, not three as with composed sequence functions)

#+BEGIN_SRC clojure
(sequence xform data)
#+END_SRC

reduce with a transformation (no laziness, just a loop)

#+BEGIN_SRC clojure
(transduce xform + 0 data)
#+END_SRC

build one collection from a transformation of another, again no laziness

#+BEGIN_SRC clojure
(into [] xform data)
#+END_SRC

create a recipe for a transformation, which can be subsequently sequenced, iterated or reduced

#+BEGIN_SRC clojure
(iteration xform data)
#+END_SRC

or use the same transducer to transform everything that goes through a channel

#+BEGIN_SRC clojure
(chan 1 xform)
#+END_SRC
* publishing to clojars
* clojure spec

** setup

project.clj dependencies 

: [org.clojure/clojure "1.9.0-alpha16"]

namespace require

: (:require [clojure.spec.alpha :as s])

** map with required keys

#+BEGIN_SRC clojure
(s/def :event/type keyword?)
(s/def :event/timestamp int?)
(s/def :search/url string?)
(s/def :error/message string?)
(s/def :error/code int?)
(defmulti event-type :event/type)
(defmethod event-type :event/search [_]
  (s/keys :req [:event/type :event/timestamp :search/url]))
(defmethod event-type :event/error [_]
  (s/keys :req [:event/type :event/timestamp :error/message :error/code]))
#+END_SRC
* dirac devtools clojurescript

steps taken to setup

    % git clone https://github.com/binaryage/dirac-sample.git
    % cd dirac-sample
    % lein demo

in another console:

    % cd dirac-sample
    % lein repl
    ...
    user=> 
    Dirac Agent v1.2.17
    Connected to nREPL server at nrepl://localhost:8230.
    Agent is accepting connections at ws://localhost:8231.

Open Chromium with command:

    % /usr/bin/chromium --remote-debugging-port=9222 --no-first-run --user-data-dir=~/.dirac 

Dirac Devtools already installed to this Chromium

In Chromium open page: 

    http://localhost:9977

When there click on the 'Click to open Dirac Devtools' green squiggly
line icon.

Devtools is opened with the green underline highlight not blue.

On webpage click on 'demo a breakpoint'

Nothing shows up in the green underline hightlight devtools, but a
'Paused in Debugger' overlay is on the webpage.

Not sure what I'm doing wrong
* vinyasa
  
  in ~project.clj~:

#+BEGIN_SRC clojure
  (defproject abc "1.0"
    :description "FIXME: write description"
    :profiles
    {:dev
     {:source-paths ["src/clj" "dev"]
      :dependencies [[im.chit/vinyasa "0.4.7"]]
      :injections
      [(require '[vinyasa.inject :as inject])
       (inject/in ;; the default injected namespace is `.`
        [clojure.pprint pprint]
        [clojure.repl apropos dir dir-fn doc find-doc pst root-cause source]
        [clojure.tools.namespace.repl refresh refresh-all]
        [dev config]
        [clojure.java.shell sh])]}})
#+END_SRC
 
Not sure if above works with CLJS, but in CLJ, you can now do
~(./refresh)~, as default namespace is ~.~  
* transducers

We have a data structure like so:

#+BEGIN_SRC clojure
  (def hand1
    ({:suit :heart, :rank 12}
     {:suit :heart, :rank 11}
     {:suit :heart, :rank 10}
     {:suit :heart, :rank 9}
     {:suit :heart, :rank 8}))
#+END_SRC

And we'd like to create a function that can tell us if this is a
straight or not.  So here is some pseudo code:

1 - Find out the distinct rank, and count that, if it = 5, then there
are no duplicate cards.

2 - Find the max and min cards, and ensure their difference is =
to 4. 

So some clojure code to encapsulate this could be:

#+BEGIN_SRC clojure
  (defn straight? [cards]
    (let [ranks (map :ranks cards)]
      (and
       (= 5 (count (into #{} ranks)))
       (= 4 (- (apply max ranks) (apply min ranks))))))

#+END_SRC

** Transduce
#+BEGIN_SRC clojure
(transduce xform f coll)
(transduce xform f init coll)
#+END_SRC

~f~ should be a reducing step function that accepts both 1 and 2 arguments

If ~init~ is not supplied, ~f~ will be called to produce it.

curl -u "fentontravers" https://api.github.com/repos/mojombo/grit/stats/contributors
* phraser

~deps.edn:~ 

: phrase {:mvn/version "0.3-alpha4"}
  
given the spec: 

#+BEGIN_SRC clojure
(s/def ::email
  (s/and #(re-find #"@" %) #(re-find #"\." %)))
#+END_SRC

when we run explain-data

#+BEGIN_SRC clojure
(s/explain-data
 :arenberg.specs.shared/email
 "abc")
;; ... (clojure.core/fn [%] (clojure.core/re-find #"@" %)), ...
#+END_SRC

we get a predicate clause indicating why the failure

Creating a phraser like:

#+BEGIN_SRC clojure
(defphraser
  #(re-find re %)
  {:via [:arenberg.specs.shared/email]}
  [_ _ re]
  (str
   "Email must include "
   (do
     (println (str "re: " re))
     (case (str/replace (str re) #"/" "")
       "@" "an ampersand symbol, @."
       "\\." "a period."
       (str "dunno blah: " re)))))
#+END_SRC

and calling it like:

#+BEGIN_SRC clojure
(phrase-first {} :arenberg.specs.shared/email "abc")
;; => "must include: an ampersand symbol, @." 
#+END_SRC

because the ~defphraser~ predicate (the first arg) matches the
predicate of explain-data AND we said this ~defphraser~ is for the
~:arenberg.specs.shared/email~ spec, it matches.

Here again is the ~explain-data~ predicate 

: (clojure.core/fn [%] (clojure.core/re-find #"@" %))

and here is the phraser predicate:

: #(re-find re %)

So #"@" gets stuffed into ~re~, and we match on it.  here is another
output of explain-data (it's predicate part):

: (clojure.core/fn [%] (clojure.core/re-find #"\." %))

so ~re~ gets #"\.", which the phraser function case matches on above.

* atom editor
apm install proto-repl ink parinfer lisp-paredit rainbow-delimiters atom-beautify atom-file-icons hasklig

* deps.edn

make a new project, we'll call it ~ds-queue~, for your own project,
replace: ~ds-queue~ with your project name below...

#+BEGIN_SRC shell
cd ~/projects
mkdir -p ds_queue/{src,test}/ds_queue ds_queue/resources/public
cd ds_queue
#+END_SRC



mkdir -p supps/{src,test}/supps supps/resources/public


: cat > .dir-locals.el 

#+BEGIN_SRC elisp -n
((nil . ((cider-default-cljs-repl . figwheel-main)
         (cider-figwheel-main-default-options . "fe_dev")
         (cider-clojure-cli-global-options . "-A:dev"))))
#+END_SRC

: cat > fe_dev.cljs.edn 

#+BEGIN_SRC clojure +n
{:main supps.core}
#+END_SRC

: cat > deps.edn

#+BEGIN_SRC clojure +n
  {:paths ["src" "resources" "target"]
   :deps {rum {:mvn/version "0.11.3"}}
   :aliases
   {:dev {:extra-paths ["test"]
          :extra-deps
          {com.bhauman/figwheel-main {:mvn/version "0.2.0"}}}
    :fig {:main-opts ["-m" "figwheel.main"]}}}
#+END_SRC

: cat > resources/public/index.html

#+BEGIN_SRC html +n
  <!DOCTYPE html>
  <html>
    <body>
      <div id="app">
        App Loading...
      </div>
      <script src="cljs-out/fe_dev-main.js" type="text/javascript"></script>
    </body>
  </html>
#+END_SRC

Here line 18 is connected to line 2 and the filename
~fe_dev.cljs.edn~.  
(note run org-preview-html-mode to see line numbers.)  

Lines 3 & 8 are connected too.

: cat > src/supps/core.cljs

#+BEGIN_SRC clojure 
  (ns supps.core
    (:require
     [rum.core :refer [defc mount] :as rum]))

  (defc hello []
    [:div "Hello!"])

  (defn main-page [comp]
    (mount
     (comp)
     (js/document.getElementById "app")))

  (main-page hello)
#+END_SRC

: cat > .gitignore

#+BEGIN_SRC shell
target/
.nrepl-port
.cpcache
#+END_SRC

Test with:

: clj -A:dev:fig -b fe_dev -r

* reagent/reframe
=======
* spectre

#+BEGIN_SRC clojure
  (setval)

(transform ALL inc [1 2 3])

;; path example
;; begin with following data:
(def data [{:a 1}
           {:b 2}])

;; ALL ==>
{:a 1}
{:b 2}

;; MAP-VALS ==>
1 2

;; 

;; (transform [ALL] inc [[1 2 3] [4 5 6]])
#+END_SRC
* postmodern - logging

#+BEGIN_SRC clojure
  ;; deps.edn
  postmortem {:mvn/version "0.2.0"}

  ;; require
  (:require [postmortem.core :as pm]
            [postmortem.xforms :as xf])
#+END_SRC

#+BEGIN_SRC clojure
  (defn abc [x y]
    (pm/dump :abc-log (xf/take-last 2))
    (+ x y))

  (abc 1 2)

  (pm/log-for :abc-log)
#+END_SRC
* reframe


>>>>>>> 33303d68a1a5e28f3768cf3fd36b3f047f557db0
* protocols, deftype

first we define a protocol, basically this is a list of methods
(functions) that an object should implement

#+BEGIN_SRC clojure
  (defprotocol MyProtocol
    (foo
      [this]
      [this x])
    (bar [this]))

  (deftype MyClass [a b]
    MyProtocol
    (foo [this] (+ 1 a b))
    (foo [this x] (+ 1 a b x))
    (bar [this] (+ a b)))

  (foo (MyClass. 1 2)) ;; --> 4
  (foo (MyClass. 1 2) 3) ;; --> 7
#+END_SRC

In our ~defprotocol~ we specified two arities for foo function.
* Ring

